---
title: "geoms"
author: "Gina Reynolds, July 2019"
output:
  xaringan::moon_reader:
    lib_dir: libs
    css: ["xaringan-themer.css", "ninjutsu"]
    nature:
      highlightLines: yes
      ratio: '16:9'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = F, message = F)
knitr::opts_chunk$set(fig.height = 6, out.width = "100%", comment = " ", cache = T, dpi = 300)
library(flipbookr)
library(tidyverse)
library(gapminder)
options(scipen = 10)
```


```{r prep_data, eval = T, echo = F}
gapminder %>% # data from package
  filter(year == 2002) -> # filtering
gapminder_2002 # saving subset object
gapminder_2002 %>% 
  filter(continent == "Europe") ->
gapminder_2002_europe  
gapminder %>% 
  filter(continent == "Europe") ->
gapminder_europe
gapminder %>% 
  select(country, continent) %>% 
  distinct() %>% 
  group_by(continent) %>% 
  summarise(country_count = n()) ->
continent_aggregate
```




---

# 'Nouns':  The geom_*() pile on

It is probably not good practice to include too many geoms in any one plot that you present.  But it might be instructive to go ahead do so here, to see how they relate, and represent the same underlying data.  

We can set opacity (alpha) to a high level to avoid completely blocking out previous geometric layers; this move previews the *unmapped aesthetics* topic - coming up. 

In the first example many "variables" are "computed on the fly", like the 0 represented by xend and yend and the mean of life exectency and per capita GDP. A point for discussion.  

---


> In ggplot2, geoms can be roughly divided into individual and collective geoms. An individual geom has a distinctive graphical object for each row in the data frame. For example, the point geom has a single point for each observation. On the other hand, collective geoms represent multiple observations. This may be a result of a statistical summary, or may be fundamental to the display of the geom, as with polygons. Lines and paths fall somewhere in between: each overall line is composed of a set of straight segments, but each segment represents two points. --- Hadley Wickham *ggplot2: Elegant graphics for data analysis*



---
class: inverse, center, middle
name: cc

## continous x and y


---

`r chunk_reveal("continuous_continuous", break_type= "rotate")`


```{r continuous_continuous, eval = F, echo =F}
ggplot(data = gapminder_2002) +
  aes(x = gdpPercap/1000) +
  aes(y = lifeExp) +
  coord_cartesian(xlim = c(0,50), ylim = c(35,90)) +
  geom_point() +
  geom_rug() + #ROTATE
  geom_tile(width = 3, height = 3, fill = "green", alpha = .25) + #ROTATE
  geom_segment(aes(xend = 0, yend = 40), alpha = .2) + #ROTATE
  geom_curve(aes(xend = 0, yend = 40), linetype = "dotted") + #ROTATE
  geom_rect(aes(xmin = 20, xmax = gdpPercap/1000, ymin = 40, ymax = lifeExp), alpha = .02, fill = "magenta", color = "grey") + #ROTATE
  geom_text(aes(label = country)) + #ROTATE
  geom_label(aes(label = country)) + #ROTATE
  stat_density_2d(aes(fill = ..density..), geom = "raster",  contour = FALSE, alpha = .5) +  #ROTATE
  geom_density2d() +  #ROTATE
  geom_smooth() +  # #ROTATE
  geom_smooth(method = lm) + #ROTATE
  geom_hex(alpha = .5,color = "white") + #ROTATE
  geom_hex(bins = 12, alpha = .9, color = "white") + #ROTATE
  ggforce::geom_voronoi_segment() + #ROTATE
  ggforce::geom_voronoi_tile(fill = "green", color = "white", alpha = .5) + #ROTATE
  ggforce::geom_voronoi_tile(aes(fill = continent, group = -1L), color = "white", alpha = .5, normalize = TRUE) + #ROTATE
  ggforce::geom_voronoi_tile(aes(fill = continent, group = -1L), colour = 'black', max.radius = 3, alpha = .5) + #ROTATE
  ggforce::geom_delaunay_tile(fill = "magenta", alpha = 0.3, colour = 'black') + #ROTATE
  ggforce::geom_delaunay_segment2(aes(color = continent, group = -1L), size = 3, lineend = 'round') + #ROTATE
  ggforce::geom_bspline_closed(alpha = 0.5, fill = "cadetblue") + #ROTATE
  ggforce::geom_bspline_closed(alpha = 0.5, fill = "cadetblue") + #ROTATE
  ggforce::geom_diagonal(aes(xend = 20, yend = lifeExp - 3), color = "goldenrod4") + #ROTATE
  ggbump::geom_sigmoid(aes(group = country, xend = 20, yend = lifeExp - 3), color = "firebrick") + #ROTATE
  geom_path(color = "plum4") + #ROTATE
  geom_polygon(alpha = 0.5, fill = "plum4") + #ROTATE
  ggforce::geom_mark_hull(aes(fill = continent)) + #ROTATE
  ggforce::geom_mark_hull(aes(fill = continent), concavity = 7) + #ROTATE
  ggforce::geom_mark_hull(aes(fill = continent, filter = continent == "Europe")) + #ROTATE
  ggforce::geom_mark_circle(aes(fill = continent)) + #ROTATE
  ggforce::geom_mark_ellipse(aes(fill = continent, filter = continent == "Europe")) + #ROTATE
  ggforce::geom_mark_rect(aes(fill = continent)) + #ROTATE
  theme_minimal()
```



---

## Questions

- How is geom_tile() different from geom_point()? Look at the help.

- What aesthetics are required for geom_rect?

- How many geometric layers are in the final plot?

- Does order of the geom_*() statements matter to the end result?  How?



---

## Single series


[Or I'm on the overview track, take me to the next session](#local)

---

`r chunk_reveal("time_series", break_type = "rotate")`

```{r time_series, include=F}
gapminder %>% 
  filter(country == "New Zealand") %>% 
  ggplot() +
  aes(x = year) +
  aes(y = pop * gdpPercap) +
  aes(group = country) +
  geom_point() +
  geom_col() + #ROTATE
  geom_segment(aes(xend = year, yend = 0)) + #ROTATE
  geom_segment(aes(xend = year, yend = 0), arrow = arrow()) + #ROTATE
  geom_line() + #ROTATE
  ggforce::geom_link2(aes(color = year, size = year, group = 1), lineend = 'round', alpha = .5) + #ROTATE
  geom_line(aes(color = year, group = 1)) + #ROTATE
  ggpattern::geom_col_pattern() + #ROTATE
  ggpattern::geom_col_pattern(aes(pattern = factor(year))) + #ROTATE
  ggpattern::geom_col_pattern(aes(pattern_fill = factor(year))) + #ROTATE
  geom_area(alpha = .4, fill = "plum1", color = "plum1") + #ROTATE
  ggforce::geom_bspline() + #ROTATE
  ggforce::geom_bezier(aes(group = 1)) + #ROTATE 
  theme_minimal()
```


---
class: inverse, center, middle
name: group


## a few series


---

`r chunk_reveal("time_series_multi", break_type = "rotate")`

```{r time_series_multi, include=F}
gapminder %>% 
  filter(continent == "Oceania") %>% 
  mutate(gdp = pop * gdpPercap) %>% 
  ggplot() +
  aes(x = year) +
  aes(y = gdp) +
  geom_point() +
  geom_line(aes(linetype = country, color = country)) + #ROTATE
  ggforce::geom_bspline(aes(linetype = country)) + #ROTATE
  geom_col(aes(fill = country), position = "dodge", alpha = .4) + #ROTATE
  geom_col(aes(fill = country), alpha = .4) + #ROTATE
  geom_area(aes(fill = country), alpha = .4) + #ROTATE
  theme_minimal()
```


---
class: inverse, center, middle
name: group

## The group aesthetic and geometric objects


---

# A final aesthetic mapping: group

Using geom_line(), you can use many of the same aesthetics as before as well as one special aesthetic: `group`.

> Lines and paths fall somewhere in between: each overall line is composed of a set of straight segments, but each segment represents two points. --- Hadley Wickham


Group is like a declaration that instead of plotting the entire data set all together, instead you will plot many small data sets, each defined by the categorical variable "mapped" to `group`.  

Let's see how this works with the following example. 

---

`r chunk_reveal("aes_group")`


```{r aes_group, eval = F, echo = F}
gapminder_europe %>% 
  ggplot() +
  aes(x = year) +
  aes(y = lifeExp) +
  geom_point() +
  geom_line() +
  aes(group = country) +
  # turning group back off
  aes(group = NULL) + 
  # mapping discrete data to color
  # or linetype has similar effects
  aes(color = country) +
  geom_point() 
```





---

The geometric object `line` connects all points as it moves along the x axis.  If a group is not defined, the geom_line is hard to interpret, as seen before group is added.  

We also see that mapping discrete data to the color or linetype aesthetics has a similar effect to declaring that there are groups in the data. 

Another thing we observe in the last addition to the last plot is adding an additional geometric layer.  The point layer, because it follows the line layer, appears on top of the line layer.  





---

`r chunk_reveal("time_series_heat", break_type = "auto")`

```{r time_series_heat, include=F}
gapminder %>% 
  filter(continent == "Europe") %>% 
  ggplot() +
  aes(x = factor(year)) +
  aes(y = country) +
  geom_tile(color = "grey80") +
  aes(fill = lifeExp) +
  scale_fill_viridis_c(option = "magma")
```


---

`r chunk_reveal("time_series_bump", break_type = "auto")`

```{r time_series_bump, include=F}
gapminder %>% 
  filter(country %in% c("Austria", "Belgium", 
                        "Norway", "Netherlands",
                        "Spain", "Italy","France")) %>%
  filter(year > 1980) %>% 
  group_by(year) %>% 
  arrange(gdpPercap) %>% 
  mutate(rank = 1:n()) %>% 
  ungroup() %>% 
  ggplot() +
  aes(x = year) +
  aes(y = rank) +
  geom_point(size = 6) +
  aes(color = country) +
  ggbump::geom_bump(size = 2, smooth = 8) +
  scale_x_continuous(limits = c(1970, 2020),
                     breaks = seq(1982, 2007, 
                                  by = 5)) +
  geom_text(data = . %>% 
              filter(year == min(year)),
            aes(x = year - 2.5, label = country), 
            size = 5, hjust = 1) +
  geom_text(data = . %>% 
              filter(year == max(year)),
            aes(x = year + 2.5, label = country), 
            size = 5, hjust = 0) +
  scale_color_manual(values = paletteer::paletteer_d("basetheme::brutal", 7)) +
  theme_minimal() +
  theme(legend.position = "none")
```





---

## Questions

geom_area() is a special case of what other geom_*()?  Use the help to answer this question. 

---

Geoms is a long section consider because there are many geoms. Consider taking the [overview track](#local).

---
class: inverse, center, middle
name: dc

## Discrete v. Continuous

---


`r chunk_reveal("geom_discrete_continuous", break_type = "rotate")`


```{r geom_discrete_continuous, eval = F, echo = F}
gapminder %>% 
  filter(year == 2002) %>%
  ggplot() +
  aes(y = continent) +
  aes(x = lifeExp) +
  geom_point(size = .2) + 
  geom_boxplot(alpha = .1) + #ROTATE
  geom_jitter(width = .2, alpha = .5, color = "green") + #ROTATE
  geom_violin(alpha = .1) + #ROTATE
  ggforce::geom_sina(col = "magenta", alpha = .5) + #ROTATE
  stat_summary(fun.y = mean, geom = "point", col = "goldenrod2", size = 8) + #ROTATE
  ggridges::geom_density_ridges(alpha = .2, fill = "blue") + #ROTATE
  ggridges::geom_density_ridges(scale = .7, alpha = .2, fill = "blue") + #ROTATE
  ggridges::geom_density_ridges(scale = 1.5, alpha = .2, fill = "blue") + #ROTATE
  ggridges::geom_density_ridges_gradient(aes(fill = stat(x))) + #ROTATE
  ggridges::stat_density_ridges(quantile_lines = TRUE, quantiles = c(0.025, 0.975), alpha = 0.5, fill = "plum4") + #ROTATE
  ggridges::geom_density_ridges(jittered_points = TRUE, position = "raincloud", alpha = .5, scale = 0.9) + #ROTATE
  ggridges::geom_density_ridges(stat = "binline", bins = 20, scale = 0.95, draw_baseline = FALSE) + #ROTATE
  ggridges::geom_density_ridges(scale = 2, alpha = .5) + ggridges::scale_fill_cyclical(values = c("blue", "green")) + #ROTATE
  theme_minimal()
```


---
class: middle, center, inverse

# Singe value per category


---

`r chunk_reveal("single_value", break_type = "rotate")`

```{r single_value, include=F}
gapminder %>% 
  filter(year == 2002) %>% 
  filter(continent == "Europe") %>% 
  ggplot() +
  aes(x = lifeExp) +
  aes(y = reorder(country, lifeExp)) +
  geom_point() +
  geom_col() + #ROTATE
  geom_segment(aes(xend = 0, yend = country)) + #ROTATE
  geom_hline(aes(yintercept = country), linetype = "dotted") + #ROTATE
  theme_minimal()
```


```{r}
# library(igraph)
# graph <- graph_from_data_frame(flare$edges, vertices = flare$vertices)
# 
# ggraph(graph, 'treemap', weight = 'size') + 
#     geom_node_tile(aes(fill = depth), size = 0.25)
```



---
name: c

## Continuous Univariate

---

`r chunk_reveal("univariate_continuous", break_type = "rotate")`


```{r, univariate_continuous, eval = F, echo = F}
ggplot(gapminder_2002) +
  aes(x = lifeExp) +
  theme_minimal() +
  geom_rug(col = "darkgrey") +
  geom_histogram(alpha = .5, fill = "cadetblue") + #ROTATE
  geom_freqpoly(linetype = "dashed") + #ROTATE
  geom_dotplot(fill = "blue", alpha = .5) + #ROTATE
  geom_dotplot(binwidth = "dotdensity", alpha = .5) + #ROTATE
  geom_histogram(col = "black", fill = "maroon4", alpha = .4, aes(y = ..density..)) + #ROTATE
  geom_density(linetype = "dotted", adjust = 1/4, size = 1.25) + #ROTATE
  geom_density(linetype = "dashed", adjust = 1/2, size = 1.25) #ROTATE
```



---
class: inverse, center, middle
name: dd

## Discrete v. Discrete

---

`r chunk_reveal("discrete2x", break_type = "rotate")`


```{r discrete2x, eval = F, echo = F}
gapminder_2002 %>% 
  mutate(seventy_plus = lifeExp >= 75) %>% 
  mutate(age_category = 
           case_when(seventy_plus == T ~ 
                       "Seventy +",
                     seventy_plus == F ~ 
                       "< Seventy")) %>% 
  ggplot() +
  aes(x = continent) +
  aes(y = age_category) +
  geom_jitter(col = "blue", alpha = .3, width = .35, height = .35) + 
  geom_count(col = "magenta", alpha = .6) + #ROTATE
  geom_text(data = . %>% group_by(age_category, continent) %>% count, aes(label = n)) + #ROTATE
  geom_label(data = . %>% group_by(age_category, continent) %>% count, aes(label = n)) + #ROTATE
  geom_point(position = ggforce::position_jitternormal()) + #ROTATE
  geom_point(position = ggforce::position_jitternormal(sd_x = 0.15, sd_y = 0.01)) + #ROTATE
  theme_minimal()
```


---

`r chunk_reveal("discrete2x2", break_type = "rotate")`

```{r discrete2x2, eval = F, echo = F}
gapminder_2002 %>% 
  mutate(seventyfive_plus = lifeExp >= 75) %>% 
  mutate(age_category = 
           case_when(seventyfive_plus == T ~ 
                       "75+",
                     seventyfive_plus == F ~ 
                       "<75")) %>% 
  ggplot() +
  aes(x = age_category) +
  aes(fill = continent) +
  geom_point(stat = "count") +
  geom_bar(position = "dodge", alpha = .6) + #ROTATE
  geom_bar(alpha = .6) + #ROTATE
  theme_minimal()
```



---

```{r, eval = F, echo = F}
require(stats)
mosaicplot(Titanic, main = "Survival on the Titanic", color = TRUE)

data(Titanic)
titanic <- as.data.frame(Titanic)
titanic$Survived <- factor(titanic$Survived, levels=c("Yes", "No"))

library(ggmosaic)
ggplot(data = titanic) +
  ggmosaic::geom_mosaic(aes(weight = Freq, x = product(Class), y = Sex, fill = Survived))

```



---
class: middle, center, inverse

# geom stats

--

### identity

--


### count


---



```{r stat, include=F}
readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2020/2020-03-03/game_goals.csv') ->
  game_goals

game_goals %>% 
  count(season) %>% 
  full_join(tibble(season = 1980:2020)) %>% 
  ggplot() +
  aes(x = season) +
  aes(y = n) +
  geom_col() + # stat is identity
  geom_point() + # stat is identity
  geom_line() + # stat is identity
  geom_area(alpha = .2, # stat is identity
            fill = "magenta") +
  aes(fill = season) +
  aes(xend = season) + 
  aes(yend = 0) +
  geom_segment(linetype = "dotted") ->
you_aggregate_then_plot

game_goals %>%
  ggplot() +
  aes(x = season) +
  geom_bar() + # a version of geom column
  geom_point(stat = "count") +
  geom_line(stat = "count") +
  geom_area(stat = "count",
            alpha = .2,
            fill = "magenta") +
  aes(fill = season) -> # not completely grasping why fill cant work here
ggplot_aggregates_for_you
```


---


```{r bar_discrete_continuous, include = F}
tibble(my_var = c(1, 2.5, 2.5, 2.5,
                  7, 7.25, 7.25)) %>% 
  ggplot() +
  aes(x = my_var) +
  geom_bar(fill = "blue", # default is  
           alpha = .5, # widths adjusted so 
           linetype = "dotted") + # no overlap
  geom_bar(alpha = .5, 
           width = .6, #setting width
           fill = "orange") + 
  # replacing previous aes x statement
  # each category take up horizontal space of 1 
  aes(x = as_factor(my_var)) 
```






```{css, eval = TRUE, echo = F}
.remark-code{line-height: 1.5; font-size: 55%}
```

