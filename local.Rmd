---
title: 'Geom specific, data, aesthetic mapping, unmapped aesthetics'
author: "Gina Reynolds, July 2019"
output:
  xaringan::moon_reader:
    lib_dir: libs
    css: ["xaringan-themer.css", "ninjutsu"]
    nature:
      highlightLines: yes
      ratio: '16:9'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = F, message = F)
knitr::opts_chunk$set(fig.height = 6, out.width = "100%", comment = " ", cache = T, dpi = 300)
library(flipbookr)
library(gapminder)
library(tidyverse)
load("data_products/manipulations.Rdata")
```


```{r xaringan-themer, include = FALSE, eval = F}
library(xaringanthemer)


# xaringanthemer::write_xaringan_theme(text_font_size = ".75cm",
#                                      text_color = "darkblue")

xaringanthemer::mono_accent(
  base_color = "#43418A",
  header_font_google = google_font("Montserrat"),
  text_font_google   = google_font("Montserrat", "200", "200i"),
  code_font_google   = google_font("Droid Mono"),
  text_font_size = ".7cm",
  code_font_size = ".7cm")
  

# write_xaringan_theme(
#   extra_css = list(
#     ".box-right" = list(
#       "height" = "300px",
#       "width" = "300px",
#       "position" = "absolute",
#       "top" = "33%",
#       "left" = "55%"
#     )
#   )
# )

```
---

name: local

# The conditional mood: geom specific data, aesthetic mapping, and unmapped aesthetics

The conditional mood is about "if".  "If I see flowers, then I pick them."

In ggplot, we also observe such conditionality.  Data and aesthetic mappings may be tied to *specific* geometric objects.  Also aesthetics that don't do any representation (unmapped aesthetics) may also be specified on a geom-by-geom basis. These specifications are "local" to a geom, rather than globally defined like the data declarations and aesthetic mapping statements we have seen before.

---

## Part i.  Going *local* with data

Let's look at tying some data to a specific geometric object in the next example.  In this example you'll also see how a 'variable' can be created *on the fly*.  




---

`r chunk_reveal("local_data", widths = c(49,50))`


```{r local_data, eval = F, echo = F}
gapminder %>% 
  filter(year == 2002) ->
gm_2002
  
gm_2002 %>% 
  filter(continent == "Oceania") ->
gm_2002_europe

ggplot(data = gm_2002) + # global data
  aes(x = gdpPercap) +  
  aes(y = lifeExp) +   
  geom_point() + 
  aes(color = continent) +
  # xend and yend are required for geom_segment
  # like creating a column with a single value, 0
  aes(xend = 0) + 
  # like creating a column with a single value, 0
  aes(yend = 0) +
  # geom specific data
  geom_segment(data = gm_2002_europe)
```



---

### Adjusting within call

---

`r chunk_reveal("local_data_filter", break_type = 1, title = "#### Manipulating data locally", widths = c(49,50))`


```{r local_data_filter, eval = F, echo = F}
gapminder %>% 
  filter(year == 2002) ->
gm_2002

ggplot(data = gm_2002) + # global data
  aes(x = gdpPercap) +  
  aes(y = lifeExp) +   
  geom_point() + 
  aes(color = continent) +
  # xend and yend are required for geom_segment
  # like creating a column with a single value, 0
  aes(xend = 0) + 
  # like creating a column with a single value, 0
  aes(yend = 0) +
  # geom specific data
  geom_segment(data = gm_2002 %>% filter(continent == "Oceania")) #<<
```

---

`r chunk_reveal("local_data_from_global", title = "#### Referring to global data locally using period (.)", break_type = 1, widths = c(49,50))`


```{r local_data_from_global, eval = F, echo = F}
gapminder %>%  #<<
  filter(year == 2002) %>%  #<<
  ggplot() + 
  aes(x = gdpPercap) +  
  aes(y = lifeExp) +   
  geom_point() + 
  aes(color = continent) +
  # xend and yend are required for geom_segment
  # like creating a column with a single value, 0
  aes(xend = 0) + 
  # like creating a column with a single value, 0
  aes(yend = 0) +
  # geom specific data
  geom_segment(data = . %>% filter(continent == "Oceania")) #<<
```


---

## Part ii. geom specific aesthetic representation

So far we have seen aesthetic "mapping" (representation) applied globally --- where aes() is an independent statement.  In this case aesthetic representation is applied to all geoms.  However, we can be specific about which geoms should take on the aesthetic representation, if we use aes() within the geom_*() statement.  This local aesthetic mapping declaration will overwrite  

An example is shown below. 

---

`r chunk_reveal("geom_specific_aes_mapping", break_type = "rotate", widths = c(49,50))`


```{r geom_specific_aes_mapping, eval = F, echo = F}
ggplot(data = gapminder_2002_europe) +
  # global aesthetics
  aes(x = gdpPercap) +  
  aes(y = lifeExp) +  
  aes(xend = 0) + # required aes for segment
  aes(yend = 0) + # required aes for segment
  geom_segment() +
  # geom specific aesthetics
  geom_point() + #ROTATE
  geom_point(aes(color = gdpPercap)) + #ROTATE
  geom_point(aes(size = gdpPercap)) + #ROTATE
  geom_point(aes(size = pop)) + #ROTATE
  geom_point(aes(color = gdpPercap, size = pop)) + #ROTATE
  geom_point(aes(color = gdpPercap, x = gdpPercap/2)) #ROTATE
  geom_point(aes(color = gdpPercap, y = 0)) #ROTATE
```




---

## Part iii. Being a dictator -- unmapped aesthetics (Imparative mode)

*Mapped* aesthetics contrast with unmapped, across-the-board, aesthetics for a geometric object.  

geom_point(color = "blue"), is an imperative -- not an ask.  A dictator move.  "Do this everywhere." It is good to show a plot with two of the same geom layer, one with mapped aesthetics and the other without.

---


`r chunk_reveal("unmapped_aes", break_type = "rotate", widths = c(59,40))`


```{r unmapped_aes, eval = F, echo = F}
gapminder %>% 
  filter(year == 2002) %>% 
  ggplot() +
  aes(x = gdpPercap) +
  aes(y = lifeExp) +
  # Another geometric layer with aesthetics 
  # that don't do representation:
  geom_point() + #ROTATE
  geom_point(color = "plum4") + #ROTATE
  geom_point(color = "steelblue") + #ROTATE
  geom_point(color = "#0FF3F3") + #ROTATE
  geom_point(size = 7) + #ROTATE
  geom_point(alpha = .5) + #ROTATE
  geom_point(color = "plum4", size = 7) + #ROTATE
  geom_point(color = "plum4", size = 7, alpha = .5) + #ROTATE
  geom_point(color = "firebrick", size = 7, alpha = .8, shape = "square") #ROTATE
```







---

# Combinations of local and global data, aesthetics


Now you know about *global* and *local* data, aesthetic representing variables, and overwriting defaults for aesthetics doing no variable representation.  Let's think about combining these.  

---

Look at the code that follows.  What are your expectations for the result?  Move forward in the presentation to check if your expectations match the actual result. 



---

`r chunk_reveal("all_conditional")`

```{r all_conditional, eval = F, echo = F}
ggplot(data = gapminder_2002) + # global data
  aes(x = gdpPercap) +  
  aes(y = lifeExp) +   
  geom_point(size = 5,
             alpha = .7) + 
  aes(color = continent) +
  # xend and yend are required for geom_segment
  # like creating a column with a single value, 0
  aes(xend = 0) + 
  # like creating a column with a single value, 0
  aes(yend = 0) +
  # geom specific data
  geom_segment(
    data = gapminder_2002_europe, #BREAK2
    aes(size = gdpPercap, #BREAK3
        alpha = pop), #BREAK3
    color = "orange" #BREAK4
    )
```

---

# Advanced aes --- conflicting desires for color and fill, for example

---

`r chunk_reveal("aes_after", widths = c(59,40), break_type = "rotate")`

```{r aes_after, include=FALSE}
gapminder_2002 %>% 
  count(continent) %>% 
  ggplot() +
  aes(x = continent) +
  aes(y = n) + 
  geom_col(aes(color = continent)) + #ROTATE
  geom_col(aes(color = continent, fill = after_scale(color))) + #ROTATE
  geom_col(aes(color = continent, fill = after_scale(alpha(color, .4)))) + #ROTATE
  geom_col(aes(color = continent), fill = NA) + #ROTATE
  geom_col(aes(color = continent, fill = NULL)) + #ROTATE
  geom_col(aes(color = continent), fill = "snow1") #ROTATE
```


---

# Even more control with stage

in the example we see how we can get transparency for outline.  alpha aes, usually refers to 

---

`r chunk_reveal("stage", widths = c(79,20), break_type = "rotate")`

```{r stage, include=FALSE}
gapminder_2002 %>% 
  count(continent) %>% 
  ggplot() +
  aes(x = continent) +
  aes(y = n) + 
  geom_col() + #ROTATE
  geom_col(aes(color = continent)) + #ROTATE
  geom_col(aes(color = continent), size = 3) + #ROTATE
  geom_col(aes(color = stage(start = continent, after_scale = alpha(color, 0.5))), size = 3)  #ROTATE
```






```{css, eval = TRUE, echo = F}
.remark-code{line-height: 1.5; font-size: 60%}
```

