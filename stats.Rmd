---
title: "stats summary"
author: "Gina Reynolds, July 2019"
output:
  xaringan::moon_reader:
    lib_dir: libs
    css: ["xaringan-themer.css", "ninjutsu"]
    nature:
      highlightLines: yes
      ratio: '16:9'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = F, message = F)
knitr::opts_chunk$set(fig.height = 6, out.width = "100%", comment = " ", cache = T, dpi = 300)
try(source("https://raw.githubusercontent.com/EvaMaeRey/little_flipbooks_library/master/xaringan_reveal_parentheses_balanced.R"))
try(source("../flipbooks/xaringan_reveal_parentheses_balanced.R"))

```

```{r}
library(tidyverse)
library(Hmisc)
```


---

```{r then, eval = F, echo = F}
ggplot(diamonds) +
  aes(x = cut) +
  aes(y = price) +
  aes(color = carat) +
  scale_color_viridis_c(option = "magma") +
  geom_jitter(alpha = .1)  + 
  stat_summary(fun.y = "mean", 
               geom = "point",
               color = "red",
               size = 4) + 
  stat_summary(fun.y = "quantile", 
               geom = "point",
               color = "magenta",
               size = 3) + 
  stat_summary(fun.y = "median", 
               geom = "point",
               color = "green",
               size = 4) 
```



`r apply_reveal("then")`

---



```{r start, eval = F, echo = F}
mtcars %>% 
  ggplot() + 
  aes(x = cyl) + 
  aes(y = mpg) +
  geom_jitter(alpha = .5, 
              width = .1) +
  aes(colour = factor(vs)) + 
  stat_summary(fun.y = "mean", 
               size = 3, 
               geom = "point") + 
  stat_summary(fun.y = "mean", 
               geom = "line",
               linetype = "dashed") +
  stat_summary(fun.y = "mean", 
               colour = "goldenrod3", 
               size = 3, 
               geom = "point") + 
  stat_summary(fun.y = "mean", 
               geom = "line",
               linetype = "dashed",
               color = "goldenrod3") + 
  stat_summary(fun.y = "mean", 
               fun.ymin = "min", 
               fun.ymax = "max", 
               colour = "plum4") +
  stat_summary(fun.data = "mean_cl_boot", 
               colour = "red", 
               size = 1) +
  stat_summary(fun.y = "mean",
               geom = "col",
               alpha = .3,
               fill = "red",
               color = "red",
               width = .5) +
  coord_cartesian(ylim = c(6, 30), xlim = c(4, 7))
```




`r apply_reveal("start")`



---

# Use coord_cartesian to specify ylim - so you don't ignor data.

```{r, eval = F, echo = F}
ggplot(mtcars) +
  aes(x = cyl) +
  aes(y = mpg) +
  geom_point() +
  stat_summary(fun.y = "mean", 
               geom = "point", 
               col = "red",
               size = 3) + 
  coord_cartesian(ylim = c(15, 30), xlim = c(4, 7))
```


---

```{r, eval = F}
# A set of useful summary functions is provided from the Hmisc package:
stat_sum_df <- function(fun, geom="crossbar", ...) {
  stat_summary(fun.data = fun, colour = "red", geom = geom, width = 0.2, ...)
}
ggplot(mtcars) +
  aes(cyl, mpg) + 
  geom_point() + 
  stat_sum_df("mean_cl_boot", 
              aes(group = cyl)) ->
d
# The crossbar geom needs grouping to be specified when used with
# a continuous x axis.
d 
d + stat_sum_df("mean_sdl", mapping = aes(group = cyl))
d + stat_sum_df("mean_sdl", fun.args = list(mult = 1), mapping = aes(group = cyl))
d + stat_sum_df("median_hilow", mapping = aes(group = cyl))

# An example with highly skewed distributions:
if (require("ggplot2movies")) {
set.seed(596)
mov <- movies[sample(nrow(movies), 1000), ]
 m2 <- ggplot(mov, aes(x = factor(round(rating)), y = votes)) + geom_point()
 m2 <- m2 + stat_summary(fun.data = "mean_cl_boot", geom = "crossbar",
                         colour = "red", width = 0.3) + xlab("rating")
m2
# Notice how the overplotting skews off visual perception of the mean
# supplementing the raw data with summary statistics is _very_ important

# Next, we'll look at votes on a log scale.

# Transforming the scale means the data are transformed
# first, after which statistics are computed:
m2 + scale_y_log10()
# Transforming the coordinate system occurs after the
# statistic has been computed. This means we're calculating the summary on the raw data
# and stretching the geoms onto the log scale.  Compare the widths of the
# standard errors.
m2 + coord_trans(y = "log10")
}
```


```{css, eval = TRUE, echo = F}
.remark-code{line-height: 1.5; font-size: 40%}
```

